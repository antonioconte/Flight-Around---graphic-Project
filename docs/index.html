<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Flight Around! A Computer Graphics project</title>
    <link href="assets/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:500,700" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Muli:400,400i,800,800i" rel="stylesheet">
    <link href="assets/css/resume.min.css" rel="stylesheet">
    <style>
    body{color: black; text-align: justify}
    </style>
  </head>

  <body id="page-top">
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary fixed-top" id="sideNav">
      <a class="navbar-brand js-scroll-trigger" href="#page-top">
        <span class="d-block d-lg-none">Flight Around!</span>
      </a>
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav">
          <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#intro">Intro</a></li>
          <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#gameplay">Gameplay</a></li>
          <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#how">Come si gioca?</a></li>
          <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#geometry">Geometria 3D e vista</a></li>
          <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#light">Illuminazione</a></li>
          <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#mesh">Mesh poligonali e Texture Mapping</a></li>
          <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#enviroment">Ambiente</a></li>
          <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#text">Testo e grafica 2D</a></li>
          <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#stencil">Riflessione</a></li>
          <li class="nav-item"><a class="nav-link js-scroll-trigger" href="#future">Conclusioni e sviluppi futuri</a></li>

        </ul>
      </div>
    </nav>

    <div class="container-fluid p-0">
      <section class="resume-section p-3 p-lg-5 d-flex d-column" id="intro">
        <div class="my-auto">
          <h1 class="mb-0">Flight Around! </h1>
          <div class="subheading mb-1">
            Antonio Conteduca - A.A. 2017-2018 <br>
            Relazione progetto del corso di "Grafica" del prof. Casciola
          </div>
          <p class="lead mb-1">
            L'obiettivo del progetto è la realizzazione di un semplice videogioco del tipo "automotive 3d game" 
            che racchiuda le principali argomentazioni affrontate nel corso. 
            Il software è pensato per ambiente UNIX e sviluppato con il linguaggio C++, 
            utilizzandolo col paradigma ad oggetti. 
            La gestione della grafica è resa possibile dalle librerie SDL e OpenGL. 
            In particolare la prima ha il compito di gestire finestre e ricevere segnali esterni, 
            mentre la seconda si preoccupa principalmente di amministrare oggetti grafici 3D. 
            L'interattività con l'utente è affidata ad un ciclo degli eventi, 
            che tramite polling(chiamata SDL_PollEvent(e) della libreria OpenGL) 
            rileva gli input esterni(SDL_Event) e reagisce in base a questi.

            Il progetto si basa e prende spunto dal codice usato per il "progettoCar" mostrato a lezione.
          </p>
        </div>
      </section>

      <hr class="m-0">

      <section class="resume-section p-3 p-lg-5 d-flex flex-column" id="gameplay">
        <div class="my-auto">
          <h2>GAMEPLAY</h2>
            <div class="resume-content mr-auto">            
                Il gioco consiste nel pilotare un aereo con l'obiettivo di accumulare più punti possibile.
                Esistono due modalita' di gioco: <b>Time Version</b>, accumula più punti entro i due minuti, e <b>Fuel Version</b>, accumula punti prima della fine del carburante.
                I punti vengono accumulati mediante le monete poste all'interno del gioco. E' prevista una terza modalita' di gioco (work in progress) che prevede la possibilita' di fare rifornimento (sez. <a href="#future">Conclusioni e sviluppi futuri</a>).
                Sono presenti premi speciali nel caso in cui vengano presi i cubi: incremento velocita', magnete e bonus di 30 punti.
            </div>
            <br>
            <div class="offset-md-2 col-md-8">
              <img width="100%" src="assets/img/menuInit.png">
              <em class="offset-md-4" >Menù iniziale del gioco</em>
            </div>

        </div> 
      </section>

      <hr class="m-0">
      <section class="resume-section p-3 p-lg-5 d-flex flex-column" id="how">
        <div class="my-auto">
          <h2>Come si gioca?</h2>
          <div class="resume-content mr-auto">
            <div class="row">
            <div class="col-md-3">
                <b>W</b>: Sali <br>
                <b>S</b>: Scendi <br>
                <b>A</b>: Sinistra<br>
                <b>D</b>: Destra<br>
                <b>SPACE</b>: Accellera<br>
                <b>P</b>: Pausa (solo fuel version)<br> 
                <b>R</b>: Cambia Camera<br>
                </div>
              <div class="col-md-4  ">
                  <b>MOUSE</b>: Gestione Camera<br>
                  <b>ESC</b>: Torna Indietro<br>         
                  <b>F1</b>: On/Off Wireframe <br>
                  <b>F2</b>: On/Off Pencil <br>
                  <b>F3</b>: Flat/Gouraud Shading <br>
                  <b>F4</b>:Luce Direzionale/Puntiforme <br>
                  <b>F11</b>: Debug Info<br>       
              </div>
                 <p>
                <b>NB.</b> La pausa funziona per la versione "fuel" del gioco in quanto la modalità a tempo non prevede le pause. Tale funzione verrà estesa nei lavori futuri.      
              </p>

            </div>
            <div>
                <div class="col-md-6 offset-md-3">
                    <img class="col-md-12" src="assets/img/camInit.png"> <br>
                    <em class="offset-md-4">Camera Iniziale (dietro)</em>
                </div>
                <div class="col-md-6 offset-md-3">
                    <img class="col-md-12" src="assets/img/internaCam.png"> <br>
                    <em class="offset-md-4">Camera Interna</em>
                </div>
                <div class="col-md-6 offset-md-3">
                    <img class="col-md-12" src="assets/img/camTop.png"> <br>
                    <em class="offset-md-4">Camera dall'alto</em>
                </div>
                <div class="col-md-6 offset-md-3">
                  <img class="col-md-12" src="assets/img/frontCam.png"> <br>
                  <em class="offset-md-4">Camera frontale</em>
              </div>
              <div class="col-md-6 offset-md-3">
                <img class="col-md-12" src="assets/img/gestioneMouse.png"> <br>
                <em class="offset-md-4">Camera gestita dal Mouse</em>
            </div>
               
                    
          </div>

          
        </div>
      </section>

      <hr class="m-0">

      <section class="resume-section p-3 p-lg-5 d-flex flex-column" id="geometry">
        <div class="my-auto">
          <h2 class="mb-1">Geometria 3D e vista</h2>

          Le trasformazioni Window-Viewport sono gestite automaticamente dalla libreria. 
          Nel progetto è stato necessario settare la Viewport tramite la chiamata <b>glViewPort</b>, 
          la quale setta il numero corretto di pixel nel Frame Buffer. <br> <br>
         
          Le coordinate dell'occhio sono moltiplicate con la matrice <b>GL_PROJECTION</b> 
          che definisce il volume di vista (frustum) e come i dati dei vertici sono proiettati. 
          Gli oggetti vengono visualizzati in proiezione prospettica, 
          settando i prametri con la funzione <b>gluPerspective</b>. 
          In tal modo viene effettuato il Clipping 3D rispetto al Volume di Vista. <br> <br>


          Le trasformazioni di modellazione hanno l'obiettivo di ricavare le coordinate mondo 
          di un particolare oggetto/vertice ed agiscono sulla matrice <b>GL_MODELVIEW</b>. Solitamente 
          sono composta dalle chiamate glScale, glRotate e glTranslate, nell'ordine specificato, 
          e comprese tra un glPushMatrix e glPopMatrix (per non intaccare lo stato dello stack dopo la trasformazione)
          per circoscrivere la trasformazione di modellazione all'oggetto desiderato. <br> <br>
          
        
          Le coordinate dopo il clipping vengono normalizzate e infine passate al processo di rasterizzazione 
          della pipeline di OpenGL. Viene usata la funzione glViewport() per definire il rettangolo dell'area
          di rendering dell'immagine finale. <br>
             
          Per muovere la telecamera la matrice GL_MODELVIEW viene moltiplicata 
          con una o più matrici di trasformazione. Nel progetto sono stati usati glTranslate e glRotate.
          <br>
          <pre>
          <code class="language-cpp">
              glViewport(0, 0, scrW, scrH); 
              glMatrixMode(GL_PROJECTION); 
              glLoadIdentity(); 
              gluPerspective(70, ((float) scrW) / scrH, 0.01, 10000); 
              glMatrixMode(GL_MODELVIEW);
              glLoadIdentity();
              setCamera(); // cambia parametri a seconda del tipo di camera selezionata 
          </code>
        </pre>

        </div>

      </section>

      <hr class="m-0">

      <section class="resume-section p-3 p-lg-5 d-flex flex-column" id="light">
          <div class="my-auto">
            <h2 class="mb-1">Illuminazione</h2>

            E' presente una luce direzionale in modo da rappresentare la luce del sole.
            Tale luce è stata settata usando la funzione glLightfv. 
            A seconda del tipo di mesh la luce si comporta in modo diverso; ciò è dovuto all'abilitazione del 
            <b>ColorMaterial</b> che permette il settaggio dei parametri del materiale di ogni singola mesh. 
            Il modello di illuminazione usato è quello di Phong composto da tre componenti: ambiente, riflessione diffusa e speculare. 
            Tali componenti sono i parametri che si settano per definire un materiale. <br><br>
            <div class="col-md-6 offset-md-3">
                <img class="col-md-12" src="assets/img/luceAereo.png"> <br>
                <em class="offset-md-3">Illuminazione sulla mesh Aereo</em>
              </div>
              <br><br>

            Di seguito è mostrato il codice utilizzato nel modulo <em>Ship.cpp</em> per settare i valori delle tre componenti dette in precedenza: <br>
                <pre>

                  <code>
                      float mat_ambient[3] ={ 1.0f, 1.0f, 0.06625f };
                      float mat_diffuse[3] ={ 0.18275f, 1.0f, 0.22525f};
                      float mat_specular[3] ={1.0f, 1.0f, 0.346435f };
                      glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
                      glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
                      glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
                      float shine = 0.21794872;
                      glMaterialf(GL_FRONT, GL_SHININESS, 128 * shine );
                      glEnable(GL_COLOR_MATERIAL); //Abilita colore sulla mesh               
                    
                      // [.... RENDER DELLA MESH] 

                      glDisable(GL_COLOR_MATERIAL); 

                    </code>
                </pre>
                
          </div>
        </section>

      <hr class="m-0">

      <section class="resume-section p-3 p-lg-5 d-flex flex-column" id="mesh">
    
          <div class="my-auto">
            <h2 class="mb-1">Mesh poligonali e Texture Mapping</h2>
            I modelli 3D nel gioco sono:
            <ul>
              <li>Ship, sul quale è stata fatta una pre-elaborazione attraverso <b>Blender</b> per separare i componenti del modello iniziale e applicare trasformazioni e texture sui singoli componenti ottenuti (ad esempio l'elica)</li>
              <li>Moneta</li>
              <li>Deserto</li>
              <li>Cubo</li>

            </ul>

            <div class="col-md-6 offset-md-3">
              <img class="col-md-12" src="assets/img/wireframe.png"> <br>
              <em class="offset-md-4">Wireframe: ON della Ship</em>
            </div>

            <div class="col-md-6 offset-md-3">
              <img class="col-md-12" src="assets/img/coin.png"> <br>
              <em class="offset-md-4">Oggetto Moneta</em>
            </div>
            <div class="col-md-6 offset-md-3">
              <img class="col-md-12" src="assets/img/desert.png"> <br>
              <em class="offset-md-5">Deserto</em>
            </div>
            <div class="col-md-6 offset-md-3">
              <img class="col-md-12" src="assets/img/cube.png"> <br>
              <em class="offset-md-5">Cubo bonus</em>
            </div>
            <br>
            La classe <em>Mesh.cpp</em> si preoccupa del reperimento dei dati da file .obj esterni tramite la funzione LoadFromObj e della renderizzazione tramite le differenti tecniche 
            NxF(<b>Flat Shading</b>) NxV (<b>Gouraud Shading</b>) attivabili mediante F3. <br><br>

            <div class="col-md-6 offset-md-3">
              <img class="col-md-12" src="assets/img/flat.png"> <br>
              <em class="offset-md-3">Flat Shading ( obj.RenderNxF() )</em>
            </div>
            <br>

            <div class="col-md-6 offset-md-3">
              <img class="col-md-12" src="assets/img/gouraud.png"> <br>
              <em class="offset-md-2">Gouraud Shading ( obj.RenderNxV() )</em>
            </div>

        
          </div>
          
         
    </section>
     

      <hr class="m-0">

      <section class="resume-section p-3 p-lg-5 d-flex flex-column" id="enviroment">
        <div class="my-auto">
          <h2 class="mb-1">Ambiente</h2>
          Il cielo è stato realizzato con una tecnica chiamata <b>cubemapping</b>, 
          ovvero un metodo di mappatura dell'ambiente che utilizza le sei facce di un cubo come forma della mappa.
          Per ognuna delle 6 facce viene utilizza una diversa texture. Il test di profondità viene 
          disabilitato quando si renderizza lo skybox per far sì che esso venga disegnato sempre dietro 
          qualsiasi mesh presente sulla scena. <br> <br>
          <div class="col-md-6 offset-md-3">
              <img class="col-md-12" src="assets/img/cubemapping.gif" alt="Flowers in Chania">
              <em class="offset-md-4">Cubemapping</em>
            </div> 
        </div>
      </section>

      <hr class="m-3">

      <section class="resume-section p-3 p-lg-5 d-flex flex-column" id="text">
        <div class="my-auto">
          <h2 class="mb-1">Testo e grafica 2d</h2>
        In basso a destra è presente la minimappa al fine di aiutare il giocatore a capire 
          dove si trova all'interno dello spazio di gioco. Questa minimappa è formata da un insieme di geometrie 2D.
           L'area in cui ci si può muovere è formata da un quadrato rosso, mentra la ship è indicata da un'immagine 
           2D della navicella, i cubi e le monete sono rispettivamente di colore verde e giallo. A seconda dell'altezza dalle 
           monete o dai cubi la dimensione dei cerchi nella mappa varia in modo da capire a quale altezza di trova l'oggetto rispetto all'altezza della ship.

           <div class="col-md-4 offset-md-4">
              <img class="col-md-12" src="assets/img/map.png"> <br>
              <em class="offset-md-4">Minimap</em>
            </div> 
            <br>
             Le posizioni di tutti gli elementi nella minimappa sono proporziali alle loro posizioni
              effettive nello spazio di gioco. In particolare, le posizioni (x,y) della minimappa 
              rispecchiano le posizioni (x,z) del mondo di gioco. In altre parole, è come se ci fosse 
              una telecamera che guarda costantemente la scena dall'alto ed ecco perchè si è deciso di implementare 
              il meccanismo descritto prima relativa alla distanza ship/moneta oppure ship/cubo.

              Per quanto il testo, viene creata una texture attraverso la funzione TTF_RenderText
              specificando gli opportuni paramentri come il testo, il colore e il font 
              (che viene caricato attraverso la funzione TTF_OpenFont). 
              Tale texture viene poi applicata a un quadrato 2D.
              <pre>
                <code>
                    void RenderTextCoord(string message, SDL_Color color, int x, int y, TTF_Font *font);
                </code>
              </pre>
                Premendo F11 viene i mostrato il pannello per il debug.
                Attraverso tale pannello è possibile vedere le configurazioni attive. <br><br>

                <div class="col-md-4 offset-md-4">
                  <img class="col-md-12" src="assets/img/debugInfo.png"> <br>
                  <em class="offset-md-4">Minimap</em>
                </div> 
        </div>
      </section>
      <hr class="m-0">

      <section class="resume-section p-3 p-lg-5 d-flex flex-column" id="stencil">
          <div class="my-auto">
            <h2 class="mb-1">Riflessione</h2>
            E' stata anche testa la riflessione del drone su una superficie, sfruttando l'Alpha Blending e lo Stencil Buffer di OpenGL. La ship viene ridisegnata nuovamente ma capovolta su una superficie che raffigura il mare.
            <br> <br>
            <div class="row">
                <div class="col-md-4 offset-md-1">
                    <img class="col-md-12" src="assets/img/stencilOn.png"> <br>
                    <em class="offset-md-3">Stencil Attivato</em>
                  </div> 
                  <div class="col-md-2"></div>
                  <div class="col-md-4">
                    <img class="col-md-12" src="assets/img/stencilOff.png"> <br>
                    <em class="offset-md-3">Stencil Disattivato</em>
                  </div>
                 
            </div>
            
          </div>
      </section>

      <section class="resume-section p-3 p-lg-5 d-flex flex-column" id="future">
        <div class="my-auto">
          <h2 class="mb-1">Conclusioni e sviluppi futuri</h2>

          Nonostante il lavoro svolto fosse incentrato sulla grafica, è stato necessario implementare 
          anche un minimo di logica per rendere il tutto più interessante e coinvolgente.
          Una delle difficoltà maggiori è stata nel capire come ragionasse OpenGL nelle trasformazioni, 
          il loro ordine e la loro esecuzione. 
          Un esempio di sviluppo futuro è stato abbozzato attraverso la <em>beta version</em> che dovrà tenere conto dei conflitti con gli altri oggetti presenti nella scena.
          <br> <br>
          <div class="col-md-8 offset-md-2">
            <img class="col-md-12" src="assets/img/futureWork.png"> <br>
          </div>          
        </div>
    </section>
     
    </div>
    <script src="assets/jquery/jquery.min.js"></script>
    <script src="assets/bootstrap/js/bootstrap.bundle.min.js"></script>
    <script src="assets/jquery-easing/jquery.easing.min.js"></script>
    <script src="assets/js/resume.min.js"></script>
  </body>

</html>
